<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Avoca Royal</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <style>
    :root{
      /* One dial to size BOTH the wheel and the header image */
      --wheel-size: clamp(320px, 64vw, 520px);

      --bg: #f7f8fb;
      --ink: #0b0f1a;
      --muted: #6b7280;
      --card: #ffffff;
      --stroke: #e5e7eb;
      --shadow: 0 8px 24px rgba(15, 23, 42, .08);
      --blue: #1976ff;
      --blue-ink: #fff;
      --green: #1fb36e;
      --red: #d83a32;
      --black: #2b2f36;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: var(--ink);
      background:
        linear-gradient(#0000 31px, rgba(0,0,0,.03) 32px) 0 0/32px 32px,
        linear-gradient(90deg,#0000 31px, rgba(0,0,0,.03) 32px) 0 0/32px 32px,
        var(--bg);
      min-height: 100vh;
      padding: 32px 20px 48px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .wedge-label { width:auto; height:auto; padding:4px 6px; border-radius:8px; }
.wedge-label .wl-num  { font-weight:900; font-size:1.05em; line-height:1; }
.wedge-label .wl-name { font-weight:600; font-size:.78em; line-height:1.05; opacity:.95; margin-top:2px; white-space:nowrap; }

    /* Header image that always equals the wheel size */
    .header { width: 100%; max-width: 1200px; margin: 0 auto 12px; display:flex; align-items:flex-start; }
    .hero-wrap { width: var(--wheel-size); }
    .hero-wrap img{ width: 100%; height: auto; display:block; }

    /* Connection pill (kept) */
    .status-indicator{
      margin-left: 18px;
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 14px; border-radius:999px; border:1px solid var(--stroke); background:#fff; box-shadow: var(--shadow);
      font-size: 13px; color:#374151;
      height: fit-content;
    }
    .status-dot{ width:8px; height:8px; border-radius:999px; background:#22c55e; }
    .status-dot.disconnected{ background:#ef4444; }

    /* Main layout */
    .main-container{
      width: 100%;
      max-width: 1200px;
      margin: 16px auto 0;
      display: grid;
      grid-template-columns: minmax(280px, var(--wheel-size)) 1fr;
      gap: 36px;
      align-items: start;
    }

    /* Wheel card */
    .roulette-table{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 20px;
      padding: 20px;
      box-shadow: var(--shadow);
      display:flex; justify-content:center;
    }

    .wheel-section{ display: flex; flex-direction: column; align-items: center; gap: 18px; }

    /* Pure circular wheel â€" no square background */
    .wheel-container{
      position: relative;
      width: var(--wheel-size); height: var(--wheel-size);
      border-radius: 50%;
      background: transparent;
    }
    #wheel{
      position: relative;
      width: 100%; height: 100%;
      border-radius: 50%;
      overflow: hidden;
      transition: transform 4s cubic-bezier(.25,.46,.45,.94);
    }
    /* inner white rings */
    #wheel::before{
      content:"";
      position:absolute; inset: calc(12px + 1.5%);
      border-radius:50%;
      box-shadow:
        inset 0 0 0 10px #ffffffcc,
        inset 0 0 0 12px #fff;
      pointer-events:none;
    }

    .pointer{
      position:absolute; top:-6px; left:50%; transform:translateX(-50%);
      width:0; height:0;
      border-left:18px solid transparent; border-right:18px solid transparent; border-top:28px solid var(--blue);
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.25));
      z-index: 5;
    }

    .wheel-center{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      width: calc(var(--wheel-size) * 0.23);
      height: calc(var(--wheel-size) * 0.23);
      border-radius:999px; background:#fff;
      border:1px solid var(--stroke); box-shadow: var(--shadow);
      display:flex; align-items:center; justify-content:center;
      padding: 8%;
    }
    /* AVOCA mark in the hub */
    .wheel-center svg{ width:100%; height:auto; display:block; }

    /* FIXED: Properly centered numeric labels on wedges */
    #wheel {
      --r: calc(var(--wheel-size) * 0.415);
    }

    .wedge-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform:
        rotate(var(--rotate))
        translateX(var(--r))
        rotate(calc(-1 * var(--rotate)))
        translate(-50%, -50%);
      transform-origin: center;

      font-weight: 800;
      font-size: clamp(12px, 2.6vw, 18px);
      font-variant-numeric: tabular-nums;
      color: #fff !important;
      text-shadow: 0 0 2px #000, 0 0 6px #000, 0 1px 2px #000;
      user-select: none;
      pointer-events: none;
      
      /* Ensure perfect centering */
      display: flex;
      align-items: center;
      justify-content: center;
      width: 1.5em;
      height: 1.5em;
      line-height: 1;
    }

    /* Right side â€" players card */
    .info-panels{ display: grid; gap: 20px; }
    .panel{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 20px;
      padding: 22px;
      box-shadow: var(--shadow);
    }
    .panel h2{ font-size: 22px; margin-bottom: 14px; }
    .panel h2 span{ font-weight: 600; }

    .participants-grid{
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 10px;
      padding: 16px;
      background: #f5f7fb;
      border: 1px solid var(--stroke);
      border-radius: 16px;
      min-height: 180px;
    }

    .participant-slot{
      background: #eef2f7;
      border: 1px solid #e3e8f0;
      border-radius: 12px;
      padding: 12px 10px;
      text-align: center;
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .participant-slot:hover{ transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0,0,0,.06); }

    .slot-number{ font-size: 20px; font-weight: 800; color:#111827; line-height: 1; }
    .slot-name{ font-size: 12px; color:#475569; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 6px; }

    .participant-slot.highlighted{
      background: var(--blue);
      border-color: #cfe2ff;
      box-shadow: 0 6px 18px rgba(25,118,255,.25);
    }
    .participant-slot.highlighted .slot-number,
    .participant-slot.highlighted .slot-name{ color: #fff; }

    /* Waitlist */
    .queue-section{ margin-top: 16px; }
    .queue-list{ display:flex; flex-wrap:wrap; gap:10px; }
    .queue-item{
      background:#eef2f7; border:1px solid #e3e8f0; color:#111827;
      border-radius: 999px; padding: 8px 14px; font-size: 13px; display:flex; gap:8px; align-items:center;
    }
    .queue-position{
      background:#e6ecfb; color:#3b63d8; border-radius: 999px; padding:2px 8px; font-weight:600; font-size:11px;
    }

    /* Winner modal (light) */
    .winner-announcement{ position: fixed; inset: 0; display:none; place-items:center; z-index: 1000; }
    .winner-announcement.show{ display:grid; }
    .winner-card{
      background:#fff; border:1px solid var(--stroke); border-radius: 24px; padding: 40px 48px; box-shadow: 0 24px 80px rgba(0,0,0,.15); text-align:center;
      animation: pop .4s ease;
    }
    @keyframes pop{ from{ transform: scale(.9); opacity: 0 } to{ transform: scale(1); opacity:1 } }
    .winner-text{ color:#6b7280; letter-spacing:.2em; text-transform:uppercase; font-size:13px; margin-bottom:8px; }
    .winner-number{ font-size:64px; font-weight:800; color:#111827; line-height:1; }
    .winner-name{ font-size:28px; margin-top:8px; }

    /* Responsive */
    @media (max-width: 1020px){
      .main-container{ grid-template-columns: 1fr; }
      .participants-grid{ grid-template-columns: repeat(5,1fr); }
    }
    @media (max-width: 560px){
      .participants-grid{ grid-template-columns: repeat(3,1fr); }
    }
  </style>
</head>
<body>
  <!-- Header image that always matches wheel size -->
  <div class="header">
    <div class="hero-wrap">
      <img src="https://cdn.prod.website-files.com/681cf5f5bab419a4de9e6b73/68b9ed9299e7ce078a91ae82_Avoca%20Royalle.svg" alt="AVOCA ROYAL â€" Donâ€™t gamble on your business">
    </div>
    <div class="status-indicator" title="Connection">
      <div class="status-dot" id="statusDot"></div>
      <span id="connectionStatus">Connected</span>
    </div>
  </div>

  <div class="main-container">
    <!-- WHEEL -->
    <div class="roulette-table">
      <div class="wheel-section">
        <div class="wheel-container">
          <div class="pointer"></div>
          <div class="wheel" id="wheel"></div>

          <!-- Center hub with AVOCA mark -->
          <div class="wheel-center" aria-label="Avoca Logo">
            <svg viewBox="0 0 129 127" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path d="M67.0111 30.1676L66.1747 30.1033C48.5039 29.3098 30.9188 26.3504 13.9128 21.3108C20.1748 28.4092 37.9743 49.4468 47.882 70.2701L48.1179 70.7634C55.6451 85.5605 61.4997 101.194 65.4027 117.407C69.1985 106.448 77.8194 83.7591 89.5285 66.6458L90.0003 65.9382C99.2432 51.3984 110.202 37.9521 122.726 26.0072C111.21 28.1517 87.4912 31.8188 67.0325 30.1676H67.0111Z" fill="#1C2128"></path>
              <path d="M89.872 76.0389C80.7363 91.3079 73.9168 109.15 70.4641 119.165L69.1774 122.875C70.9359 126.671 75.9326 127.936 79.2352 125.041C85.9689 119.187 92.6813 113.332 99.4151 107.456C101.281 105.826 102.053 103.296 101.409 100.915C98.7074 90.8576 96.0053 80.7998 93.3032 70.742L89.8934 76.1033L89.8505 76.0389H89.872Z" fill="#1C2128"></path>
              <path d="M5.69941 20.1102C2.13951 20.5391 -0.626909 23.9274 0.123672 27.7661C1.83929 36.5158 3.5549 45.2868 5.24907 54.0365C5.72086 56.4598 7.5437 58.4113 9.92412 59.0332C20.0248 61.7353 30.1469 64.4375 40.2476 67.1396C30.1684 48.4608 14.7064 30.3181 9.88123 24.8281L5.69941 20.0888V20.1102Z" fill="#1C2128"></path>
              <path d="M75.3532 25.1931C92.8739 25.4934 111.445 22.6411 121.718 20.7325L126.736 19.8104C129.609 16.4006 128.258 11.0607 123.926 9.581C115.499 6.6859 107.049 3.79082 98.6212 0.895726C96.2837 0.102254 93.6888 0.702656 91.9517 2.43972C84.4888 9.92408 77.0045 17.387 69.5415 24.8714L75.4175 25.1287L75.3746 25.2145L75.3532 25.1931Z" fill="#1C2128"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: PLAYERS -->
    <div class="info-panels">
      <div class="panel">
        <h2>Players (<span id="participantCount">11</span>/36)</h2>
        <div class="participants-grid" id="participantsGrid"><div class="participant-slot ">
          <div class="slot-number">1</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">2</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">3</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">4</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">5</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">6</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">7</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">8</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">9</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">10</div>
          <div class="slot-name"></div>
        </div><div class="participant-slot ">
          <div class="slot-number">11</div>
          <div class="slot-name"></div>
        </div></div>

        <div class="queue-section" id="queueSection" style="display:none;">
          <h3 style="font-size:18px; margin:14px 0 10px;">Waitlist (<span id="queueCount">0</span>)</h3>
          <div class="queue-list" id="queueList"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Winner modal -->
  <div class="winner-announcement" id="winnerAnnouncement">
    <div class="winner-card">
      <div class="winner-text">Winner</div>
      <div class="winner-number" id="winnerNumber">1</div>
      <div class="winner-name" id="winnerName">Fede C</div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIG
    // ============================================

    // tweakable label-centering knobs



    const AIRTABLE_CONFIG = {
      API_KEY: 'patjFd8AqLFaguOEe.0926a467696986c2920b20907d6f7b8bc468592117c50e02d4303fbc29eb0ac1',
      BASE_ID: 'appQm84VJgrmPJZal',
      PARTICIPANTS_TABLE: 'Participants',
      ADMIN_TABLE: 'Admin Controls',
      POLLING_INTERVAL: 500
    };

    // ---- CALIBRATION (single source of truth) ----
const CAL = {
  pointerDeg: 90,  // pointer at 12 o’clock in conic-gradient coords
  labelDeg: 0      // tiny nudge if labels look a hair off (e.g., 0.5 or -0.5)
};

   

    // ============================================
    // STATE & URL PARAMS
    // ============================================
    let appState = { participants: [], queue: [], isSpinning: false, highlightIndex: -1 };

    const urlParams = new URLSearchParams(window.location.search);
    const norm = s => (s || "").toString().trim().toLowerCase();
    const userEmail = urlParams.get('email');
    const userName  = urlParams.get('name');
    const userKey   = norm(userName) || norm(userEmail);

    window.userKey = userKey;

    // ============================================
    // AIRTABLE HELPERS
    // ============================================
    function updateConnectionStatus(state){
      $('#connectionStatus').text(
        state === 'connected' ? 'Connected' :
        state === 'error' ? 'Connection Error' : 'Connecting...'
      );
      $('#statusDot').toggleClass('disconnected', state!=='connected');
    }

    async function fetchFromAirtable(tableName, params = {}){
      try{
        let url = `https://api.airtable.com/v0/${AIRTABLE_CONFIG.BASE_ID}/${tableName}`;
        const sp = new URLSearchParams();
        Object.entries(params).forEach(([k,v])=>{
          if(k==='sort' && Array.isArray(v)){ v.forEach(o=>{ sp.append('sort[0][field]', o.field); sp.append('sort[0][direction]', o.direction); }); }
          else if(typeof v==='string' || typeof v==='number'){ sp.append(k, v); }
        });
        if(sp.toString()) url += `?${sp.toString()}`;
        const res = await fetch(url, { headers:{ Authorization:`Bearer ${AIRTABLE_CONFIG.API_KEY}` }});
        if(!res.ok) throw new Error(await res.text());
        const data = await res.json(); return data.records || [];
      }catch(e){ console.error(e); throw e; }
    }
    async function updateAirtableRecord(tableName, recordId, fields){
      const url = `https://api.airtable.com/v0/${AIRTABLE_CONFIG.BASE_ID}/${tableName}/${recordId}`;
      const res = await fetch(url, { method:'PATCH', headers:{ 'Authorization':`Bearer ${AIRTABLE_CONFIG.API_KEY}`, 'Content-Type':'application/json' }, body: JSON.stringify({ fields })});
      if(!res.ok) throw new Error(await res.text());
      return res.json();
    }

async function fetchParticipants(){
  try{
    const records = await fetchFromAirtable(AIRTABLE_CONFIG.PARTICIPANTS_TABLE, {
      filterByFormula: "OR({Status} = 'Active', {Status} = '')",
      maxRecords: 100
    });

    // Map only — do NOT sort by weight; preserve Airtable view/order
    const list = records.map(r=>({
      id:     r.id,
      name:   r.fields.Name   || 'Anonymous',
      email:  r.fields.Email  || '',
      weight: Number.isFinite(+r.fields.Weight) && +r.fields.Weight > 0 ? +r.fields.Weight : 1,
      status: r.fields.Status || 'Active',
      // If you have a Slot column in Airtable, keep it too (optional):
      slot:   Number.isInteger(r.fields.Slot) ? r.fields.Slot : undefined
    }));

    return list;
  }catch(e){
    updateConnectionStatus('error');
    return [];
  }
}

    function ensureSlotsStable(list) {
  // assign a fixed 'slot' once; keep array sorted by that slot forever
  const withSlots = list.map((p, i) => ({
    ...p,
    slot: Number.isInteger(p?.slot) ? p.slot : i
  }));
  withSlots.sort((a, b) => a.slot - b.slot);
  // cap to 36 if you use a max
  return withSlots.slice(0, 36);
}

// ============================================
// FIXED WHEEL RENDERING
// ============================================


function createWheel() {
  const $wheel = $('#wheel');
  $wheel.empty();

  const list = appState.participants || [];
  const n = list.length;
  if (!n) return;

  const seg = 360 / n;

  // Build conic slices in native conic coords (0° = 3 o’clock)
  const stops = [];
  for (let i = 0; i < n; i++) {
    const start = i * seg;
    const end   = (i + 1) * seg;

    const baseColor = (i % 2 === 0) ? '#d83a32' : '#2b2f36';
    const color = baseColor; // keep wheel un-highlighted; grid does highlight
    stops.push(`${color} ${start}deg ${end}deg`);
  }
  $wheel.css('background', `conic-gradient(${stops.join(',')})`);

  // Labels: mid-angle of each slice (+ tiny CAL.labelDeg if you need)
  for (let i = 0; i < n; i++) {
    const midA = i * seg + seg / 2;
    const p = list[i];
    const num = (p.slot ?? i) + 1;
    const $label = $(`
  <div class="wedge-label" style="--rotate:${midA + CAL.labelDeg}deg;">
    <span class="wl-num">${num}</span>
  </div>
`);
    $wheel.append($label);
  }
}

      function updateParticipantsDisplay(){
        const grid = $('#participantsGrid'); const count = $('#participantCount');
        const list = appState.participants.slice(0,36);

        if(!list.length){
          grid.html(`<div style="grid-column:1/-1; text-align:center; color:#6b7280; padding:32px 12px;">Waiting for players to join...</div>`);
          count.text('0'); return;
        }

        let html = '';
        list.forEach((p,i)=>{
          const isHighlighted = (i === appState.highlightIndex);
          html += `<div class="participant-slot ${isHighlighted?'highlighted':''}">
            <div class="slot-number">${i+1}</div>
            <div class="slot-name">${isHighlighted ? (p.name || '') : ''}</div>
          </div>`;
        });
        grid.html(html);
        count.text(list.length);
      }

    function updateQueueDisplay(){
      const $sec = $('#queueSection'), $list = $('#queueList'), $count = $('#queueCount');
      if(!appState.queue.length){ $sec.hide(); } else{
        $sec.show(); $list.empty();
        appState.queue.forEach((p,idx)=>{
          $list.append(`<div class="queue-item"><span>${p.name || 'Guest'}</span><span class="queue-position">#${appState.participants.length + idx + 1}</span></div>`);
        });
      }
      $count.text(appState.queue.length);
    }

    

    // ============================================
    // FIXED SPIN LOGIC
    // ============================================
function chooseWeightedIndex(list) {
  if (!Array.isArray(list) || list.length === 0) return 0;

  // Normalize weights to sane positive numbers
  const W = list.map(p => {
    const w = Number(p?.weight);
    return Number.isFinite(w) && w > 0 ? w : 1;
  });

  // Sum safely
  let total = 0;
  for (let i = 0; i < W.length; i++) total += W[i];

  // If total is broken (NaN/0), fall back to uniform random
  if (!Number.isFinite(total) || total <= 0) {
    const idx = Math.floor(Math.random() * list.length);
    console.log('[chooseWeightedIndex:fallback]', { idx, reason: 'bad-total', total, W });
    return idx;
  }

  // Roll
  let r = Math.random() * total;
  for (let i = 0; i < W.length; i++) {
    r -= W[i];
    if (r < 0) {
      console.log('[chooseWeightedIndex]', { picked: i, W, total });
      return i;
    }
  }
  console.log('[chooseWeightedIndex:endcap]', { picked: W.length - 1, W, total });
  return W.length - 1;
}

    let lastSpinIdSeen=null, spinLockUntil=0;

async function checkSpinTrigger() {
  try {
    const recs = await fetchFromAirtable(AIRTABLE_CONFIG.ADMIN_TABLE, {
      filterByFormula: "{Trigger Spin} = TRUE()",
      maxRecords: 1
    });
    if (!recs.length || appState.isSpinning) return false;

    const rec = recs[0];
    await updateAirtableRecord(AIRTABLE_CONFIG.ADMIN_TABLE, rec.id, {
      "Trigger Spin": false
    });

    return true;
  } catch (e) {
    console.error(e);
    return false;
  }
}

async function spinWheel() {
  if (appState.isSpinning) return;

  const $wheel = $('#wheel');
  const list = appState.participants || [];
  const n = list.length;
  if (!n) return;

  // Pick winner from the SAME array instance used for labels/grid
  const winnerIndex = chooseWeightedIndex(list);
  const winner = list[winnerIndex];

  // Math: land the midpoint of the winning slice under the pointer at CAL.pointerDeg
  const seg = 360 / n;
  const target = winnerIndex * seg + seg / 2;       // slice midpoint in conic coords
  const baseTurns = 8 * 360;                         // cosmetic spins
  const finalRotation = baseTurns + (CAL.pointerDeg - target);

  appState.isSpinning = true;
  $wheel.css('transition', 'transform 4s cubic-bezier(.17,.67,.19,1)');
  // force reflow for re-animating
  // eslint-disable-next-line no-unused-expressions
  $wheel[0].offsetHeight;
  $wheel.css('transform', `rotate(${finalRotation}deg)`);

  $wheel.one('transitionend', () => {
    // Verify index under the pointer
    const st = window.getComputedStyle($wheel[0]).transform;
    let rotDeg = 0;
    if (st && st !== 'none') {
      const m = st.match(/matrix\(([^)]+)\)/);
      if (m) {
        const [a, b] = m[1].split(',').map(parseFloat);
        rotDeg = Math.atan2(b, a) * (180 / Math.PI);
      }
    }
    rotDeg = ((rotDeg % 360) + 360) % 360;
    const angleUnderPointer = ((CAL.pointerDeg - rotDeg) % 360 + 360) % 360;
    const idxAtPointer = Math.floor(angleUnderPointer / seg);

    console.groupCollapsed('[post-spin check]');
    console.log({ n, seg, winnerIndex, idxAtPointer, target, pointerDeg: CAL.pointerDeg, rotDeg, angleUnderPointer });
    console.groupEnd();

    // Grid highlight + modal (match your DOM ids)
    appState.highlightIndex = winnerIndex;
    updateParticipantsDisplay();
    createWheel();

    const num = (winner.slot ?? winnerIndex) + 1;
    $('#winnerNumber').text(num);
    $('#winnerName').text(winner?.name || 'Winner');
    $('#winnerAnnouncement').addClass('show');
    setTimeout(() => $('#winnerAnnouncement').removeClass('show'), 6000);

    appState.isSpinning = false;
  });
}

    // ============================================
    // REFRESH & POLLING
    // ============================================
// ---------- helpers used inside refreshData ----------
function _norm(s){ return (s || "").toString().trim().toLowerCase(); }
function _id(p){                     // stable identity across refreshes
  const email = _norm(p.email);
  const name  = _norm(p.name);
  return email || name;              // prefer email; fall back to name
}
function _sig(arr){                  // quick equality signature
  return (arr || []).map(p => `${_id(p)}::${Number(p.weight ?? 1)}`).join('|');
}
function normalizeRoster(raw){
  const out = [];
  const seen = new Set();
  for (const r of (raw || [])){
    const p = {
      name:  (r.name  ?? r.Name  ?? '').toString().trim(),
      email: (r.email ?? r.Email ?? '').toString().trim(),
      weight: Number(r.weight ?? r.Weight ?? 1)
    };
    const key = _id(p);
    if (!key || seen.has(key)) continue;  // drop empties/dupes
    seen.add(key);
    if (!isFinite(p.weight) || p.weight <= 0) p.weight = 1;
    out.push(p);
  }
  return out;
}
function ensureSlotsStable(prevList, nextList){
  // Keep people in the same slot they had before, append truly new people at the end.
  const prevIndexById = new Map();
  (prevList || []).forEach((p,i) => prevIndexById.set(_id(p), i));

  // Attach desired index if known
  const withIdx = nextList.map(p => ({ p, idx: prevIndexById.get(_id(p)) }));
  // Sort: known index first by old order, then unknowns by original order
  withIdx.sort((a,b) => {
    const ai = (a.idx ?? Number.POSITIVE_INFINITY);
    const bi = (b.idx ?? Number.POSITIVE_INFINITY);
    return ai - bi;
  });
  return withIdx.map(x => x.p);
}
// ---------- end helpers ----------

/**
 * Fetch participants, keep first `cap` on the wheel, queue the rest,
 * highlight "you", and update UI without disturbing an in-progress spin.
 */
async function refreshData(cap = 36){
  try{
    if (typeof updateConnectionStatus === 'function') updateConnectionStatus('connecting');

    // 1) Load + clean + dedupe
    const allRaw = await fetchParticipants();                 // <-- your existing fetcher
    const all    = normalizeRoster(Array.isArray(allRaw) ? allRaw : []);

    // 2) Wheel list + queue
    const list = all.slice(0, cap);
    appState.queue = all.slice(cap);

    // 3) Keep slot order stable relative to what's currently on screen
    const prev = appState.participants || [];
    const stable = ensureSlotsStable(prev, list);

    // 4) Only replace roster if it actually changed (prevents flicker)
    const changed = _sig(prev) !== _sig(stable);
    if (changed) appState.participants = stable;

    // 5) Highlight “you” in the grid (by email first, then name)

const key = _norm(window.userKey || '');
if (key) {
  const emailIdx = stable.findIndex(p => _norm(p.email) === key);
  const nameIdx  = stable.findIndex(p => _norm(p.name)  === key);
  appState.highlightIndex = (emailIdx !== -1) ? emailIdx : nameIdx;
} else {
  appState.highlightIndex = -1;
}

    // 6) Update UI (skip during spin; defer until the spin finishes)
    const doRender = () => {
      if (typeof createWheel === 'function') createWheel();
      if (typeof updateParticipantsDisplay === 'function') updateParticipantsDisplay();
      if (typeof updateQueueDisplay === 'function') updateQueueDisplay();
      if (typeof updateConnectionStatus === 'function') updateConnectionStatus('connected');
    };

    if (!appState.isSpinning){
      doRender();
    } else {
      // Defer a single refresh until the current spin ends
      const $wheel = $('#wheel');
      // Avoid stacking multiple listeners across calls
      $wheel.off('transitionend.refreshOnce').one('transitionend.refreshOnce', () => {
        // Guard: if something re-started a spin, skip again
        if (!appState.isSpinning) doRender();
      });
    }
  } catch (err){
    console.error('[refreshData] failed:', err);
    if (typeof updateConnectionStatus === 'function') updateConnectionStatus('error');
  }
}

    let pollBusy=false;
    async function pollForUpdates(){
      if(pollBusy) return; pollBusy = true;
      try{
        if(!appState.isSpinning){ const t = await checkSpinTrigger(); if(t){ await spinWheel(); pollBusy=false; return; } }
        await refreshData();
      }finally{ pollBusy=false; }
    }

    // ============================================
    // INIT
    // ============================================
    $(document).ready(function(){
      refreshData();
      setInterval(pollForUpdates, AIRTABLE_CONFIG.POLLING_INTERVAL);
    });

    function debugMapping(){
  (appState.participants||[]).forEach((p,i)=>{
    console.log(`Slice ${i+1} → ${p?.name || p}`);
  });
}
debugMapping();

(() => {
  const hi = appState.highlightIndex;
  if (hi < 0) return console.log("No slice currently highlighted.");
  const p = appState.participants[hi];
  console.log(`[highlight] slice #${hi+1} → ${p?.name || p}`);
})();

(() => {
  const wheel = document.getElementById('wheel');
  const style = getComputedStyle(wheel);
  const t = style.transform;
  let angle = 0;
  if (t && t !== 'none') {
    const m = t.match(/matrix\(([-0-9., ]+)\)/);
    if (m) {
      const parts = m[1].split(',').map(Number);
      const [a,b] = parts; // cosθ, sinθ
      angle = Math.round((Math.atan2(b, a) * 180 / Math.PI));
    }
  }
  const n = appState.participants.length;
  const seg = 360 / n;
  // we use 12 o’clock reference → pointerAngle = 90deg in CSS-land
  const pointerAngle = 90;
  const currentAngle = ((pointerAngle - angle) % 360 + 360) % 360;
  const indexUnderPointer = Math.floor(((currentAngle + seg/2) % 360) / seg);
  const p = appState.participants[indexUnderPointer];
  console.log(`[pointer] angle=${angle}°, seg=${seg.toFixed(2)}°, slice #${indexUnderPointer+1} → ${p?.name || p}`);
})();
  </script>


</body></html>
